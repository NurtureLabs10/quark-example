![image](https://i.imgur.com/NhuaxOM.png)
# Quark
## A fast indexer for all EVM chains

> This repo is at an experimental stage. Use it at your own risk.

### Idea
It's not that the current indexing solutions like theGraph protocol aren't good, they weren't ideal for our use case so we decided to build our indexing solution. We at Nurturelabs have been building dapps for a year and indexing was one thing that was always required. A lot of solutions in the market focus on subscriptions to events via webhooks but that is not ideal. It leaves the task to process and organize the event logs on a separate system which may go down and miss an event corrupting the data integrity.

TheGraph got all these things right but we needed something
- where we could programmatically create new indexes
- reindex them much more quickly whenever changes were made to the callbacks or the models 
- ensure its uptime ourselves instead of relying on their hosted service
- make subgraphs/indexes that scanned multiple contracts across multiple chains at the same time
- allowed more complex callbacks to be written

Also, we wanted something in Python so that we can comfortably edit it as our needs evolve.

### Index
In quark an Index is equivalent to a subgraph in theGraph.

A single index definition contains the contracts to scan across all EVM chains, their callbacks for each event, the models(DB tables) those callbacks will save to.

### Key Examples
One major use case for us is querying the data across multiple chains at the same time.

If you are a multichain options protocol and you want to show a user all the options they currently own across all the chains. In theGraph you'll have to make the subgraphs on each chain and then query them all and then combine the data, sort it, and then display it to the user. In the case of Quark you can make one index for all these options contracts across all the chains and then make a single query to get all the data in one go.

This use case is even more strengthened when you have multiple options contracts for different assets on each chain, For example, one contract for BNB/USD, then for ETH/USD, and so on. The number of subgraphs you have to make and the query to will quickly become infeasible to do via theGraph and you'll need to redesign your contracts in such a way that the events are generated by one aggregating contract. Quark removes that complexity and makes it super simple to do such queries too.

### What can it do?
- Index any EVM chain, even the `bsc-tesnet` chain and `nervos` chain not covered in the graph hosted service.
- Can be integrated into your Python/Django backend -- something specific for us
- A large number of blocks can be scanned in one go - Scans blocks at the max blocks per scan limit for each chain and adjusts the scan size accordingly if the call fails 
- Callbacks can be defined for each event so that processed tables can be kept up to date
- Data integrity is maintained and we ensure callbacks aren't executed again for the same event log
- Generic read and write for all EVM chains
- Simple reindexing controls and management of multiple indexes

### Things to do
- [ ] Make a generic python package on pypi
- [ ] Add support for other ORMs
- [ ] Make a hosted version with a GraphQL interface
- [ ] Add parallelization to the event fetching to increase indexing speed
- [ ] Build documentation 

### Running on local
```bash
mkdir app/staticfiles
mkdir data
docker-compose -f local.yml up --build
```

Then go to the Jupyter Notebook server running inside the docker container and start the Notebook `Run Indexer.ipynb` and then run it.

That will start indexing the chains for the `index_v1` definition and store all the data to PostgreSQL DB also running inside the docker container. 

Once the scanning is done you can build any APIs over the indexed data.
